/* 
TODO
- [x] images sizes and resolutions!!!! no @astro/images here!
  - Is the answer here?: All images in Slideshow are max-res anyway, cause most detailed?
  - Or can we use generated images from @astro/images, already generated for grid gallery on build? (hardlinkS?)

- [x] animate it 

- [ ] image preloading! --> index?!
- [ ] need to set index to current index for page reload!?

- [ ] Mouse Click and drag left/right =  prev/next
- [ ] Touch swipe left right? = prev/next

- [ ] simplify next/prevSlide funcitons into one funciton

- [ ] Zoomed View on Click or on Click Button Zoom ?!
*/

import "../styles/slideshow.css";
import React, { useState, useEffect, useRef, } from 'react';
import { AnimatePresence, motion, useDragControls } from 'framer-motion';

import { useStore } from '@nanostores/react';
import { slideshow_length, stateSlideshow, statePlayback, stateSlideshowIndex, stateSlideshowDirection, slideshowCurrentAlt, slideshowAutoPlayInterval, stateSlideshowZoom } from '../states.jsx';

const animation_variants = {
  i: direction =>  { 
    //test if direction > 0 dann 1000 sonst -1000
    return{
      x: direction > 0 ? 1000 : -1000,
      opacity: 0,
      // scale: 0.5,
    }
  },
  a: {
    x: 0,
    opacity: 1,
    z:0,
    // scale: 1,
    transition: {
      // height: { type: 'tween', duration: 1, ease: "easeInOut" },
      x: { type: 'spring', stiffness: 100, damping: 15 },
      opacity: {duration: 0.2 }
    },
    // transition: 'ease-in',
  },
  e: direction => {
    console.log(direction);
    return{
      z: 0,
      x: direction > 0 ? -1000 : 1000,
      opacity: 0,
      // scale: 0.5,
      transition: {
        x: { type: 'spring', stiffness: 100, damping: 15 },
        opacity: {duration: 0.2 }
      },
      // transition: 'ease-in',
    }
  },
}

const animation_zoom = {
  i:{
    scale: 1,
  },
  a:{
    scale: 3.2, 
    transition: { type: 'spring', stiffness: 100, damping: 15 },
  },
  e:{
    scale:1,
  }
}

function Slideshow(props) {

  const index = useStore(stateSlideshowIndex)
  const direction = useStore(stateSlideshowDirection)

  //Toggle for Images/Plans
  const sToggle = useStore(stateSlideshow);
  const setSlidesToggle = () => {
    stateSlideshow.set(!sToggle);
    stateSlideshowZoom.set(false);
  }

  let images = sToggle ? props.pictures : props.plans;
  let alts = sToggle ? props.pictureTitles : props.planTitles;
  ;

  //Toggle for Zoom
  const zToggle = useStore(stateSlideshowZoom);
  const setZoomToggle = () => {
    stateSlideshowZoom.set(!zToggle);
  }
  // change Controls color on Plan/Picture Toggle
  useEffect(() => {
    const footerControls = document.querySelector(".controls");
    footerControls.style.color = sToggle ?  'var(--cwhite)' : 'var(--cgrey)';
    footerControls.style.color = zToggle && sToggle ?  'var(--cwhite)' : 'var(--cgrey)';
  }, [sToggle, zToggle]) 

  // export current States for counter etc.
  const exportToStates = () => {
    slideshow_length.set(images.length);
    slideshowCurrentAlt.set(alts[index]);
    slideshowAutoPlayInterval.set(props.autoPlayInterval);
    // console.log(interval)
  }
  exportToStates();

  // Keyboard Hotkeys/Shortcuts
  useEffect(() => {

    const handleKeyDown = (event) => {
      switch(event.key) {
        case 'ArrowLeft':
        case 'h':
          prevSlide(event);
          break;
        case 'ArrowRight':
        case 'l':
          nextSlide(event);
          break;
          // somehow only sets to false 
        case 'p':
          setSlidesToggle();
          stateSlideshowIndex.set(0);
          break;
        case ' ':
        case 'w':
          togglePlayback();
          break;
        case 'z':
          setZoomToggle();
          break;
        default:
          break;
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  },);

  // Auto Playback 

  const pToggle = useStore(statePlayback);
  const togglePlayback = () => {
    statePlayback.set(!pToggle);
  }

  const autoPlayRef = useRef();

  useEffect(() => {
    autoPlayRef.current = nextSlide;
  })

  useEffect(() => {
    const play = () => {
     const dummyEvent = { stopPropagation: () => {} };
      autoPlayRef.current(dummyEvent)
    }
    if(props.autoPlayInterval > 0 && pToggle){
      const interval = setInterval(play, props.autoPlayInterval * 1000);
      return () => clearInterval(interval);
    };
  }, [props.autoPlayInterval, pToggle])

  // Swipe touch events: 
  const [touchStart, setTouchStart] = useState(null);
  const [touchEnd, setTouchEnd] = useState(null);

  const minSwipeDistance = 50;

  const onTouchStart = (e) => {
    setTouchEnd(null); 
    setTouchStart(e.targetTouches[0].clientX);
  };

  const onTouchMove = (e) => setTouchEnd(e.targetTouches[0].clientX);

  const onTouchEnd = (event) => {
    if (!touchStart || !touchEnd) return;
    const distance = touchStart - touchEnd;
    const isLeftSwipe = distance > minSwipeDistance;
    const isRightSwipe = distance < -minSwipeDistance;
    if (isLeftSwipe) nextSlide(event);
    if (isRightSwipe) prevSlide(event);
  };


  // #rev should only be one function
  function nextSlide(event){
    event.stopPropagation();
    stateSlideshowDirection.set(1)
    if(index === images.length -1){
      stateSlideshowIndex.set(0)
    } else {
      stateSlideshowIndex.set(index + 1);
    }
  }

  function prevSlide(event){
    event.stopPropagation();
    stateSlideshowDirection.set(-1)
    if(index === 0){
      stateSlideshowIndex.set(images.length -1)
    } else {
      stateSlideshowIndex.set(index - 1);
    }
  }

// const controls = useDragControls()
  return (
    <AnimatePresence 
    initial={false}
    custom={direction}
    >
    <div
    className="slideshow_div"
    >


    <motion.figure
    className={`slideshow_fig ${!zToggle ?'slidshow_fig_zoomed_out' : ''}`}
    onTouchStart={onTouchStart}
    onTouchMove={onTouchMove}
    onTouchEnd={onTouchEnd}

    variants={animation_variants}
    initial="i"
    animate="a"
    exit="e"

    key={images[index]}
    custom={direction}
    >

    <motion.img
    className={`slideshow_img ${!sToggle ? '' : ''} ${!zToggle ?'zoom_out' : ''}`} 

    variants={animation_zoom}
    animate={zToggle ? "a" : "i"}
    initial="i"
    exit="e"

    onClick={setZoomToggle}

    drag={zToggle ? true : false}
    dragSnapToOrigin={true}
    dragConstraints={{top: 100 , right: 100, left: 100, bottom: 100}}

    src={images[index]}
    alt={alts[index]} 
    draggable={false}
    /> 

    <img
    className="hidden"
    src={images[index-1]}
    />

    <img
    className="hidden"
    src={images[index+1]}
    />

    <figcaption>{alts[index]}</figcaption>

    <button className="slideshow_btn btn_prev" onClick={prevSlide}> ◀️ vorheriges Bild </button>
    <button className="slideshow_btn btn_next" onClick={nextSlide} > ▶️ nächstes Bild </button>

    </motion.figure>
    </div>
    </AnimatePresence>
  )
}

export default Slideshow;
